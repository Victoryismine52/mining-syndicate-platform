# Card Builder – Use Case and Requirements

## Overview

The Card Builder is a tool that allows an admin or designer to visually create a single card UI component for the platform. The card is composed of predefined data elements (from a shared data library) that can be arranged and customized. The builder provides a drag-and-drop interface to construct the card and a real-time preview of its appearance. Users can also toggle to view or edit the underlying configuration code (such as JSON or React component code) at any time. This document outlines a typical use case for designing a card and details the functional requirements for the Card Builder MVP (Minimum Viable Product).

## Use Case Scenario: Designing a New Card

**Actor:** Site administrator or content designer (authorized user)

**Goal:** Visually assemble a card with chosen data elements, style it, and export its definition for use in the application.

### Main Flow

1. **Open Card Builder:** The user navigates to the Card Builder interface (available as a separate tool or within an admin dashboard). They see a palette or library of predefined data elements (the data library) on one side, and an empty card canvas or preview area on the other. The data elements are listed with their names and perhaps categorized (e.g. "Text Fields", "Numbers", or domain-specific groups) for easy browsing. Each element in the library has a label and a defined data type or purpose (for example: Title (text), Amount (number), Image, etc.). The Card Builder ensures the user only sees elements that are available for use in cards (some elements might be system-defined vs. custom, indicated accordingly).
2. **Select and Configure Element:** The user selects a data element they want on the card. Each data element offers one or more display modes depending on its nature. For example, an element might be available as:
   - a read-only display field (shows data that cannot be edited by end-users),
   - an editable display field (shows data that an end-user can update inline), or
   - an input field (for entering new data).

   The builder UI indicates which display options are allowed for the chosen element (the options are dictated by the element’s definition in the data library). The user chooses the desired display mode for that element. (For instance, a “Customer Name” element could be placed as a read-only label or as an input box if editing is needed.)
3. **Drag and Drop onto Card:** The user drags the configured element from the library into the card canvas area. The Card Builder supports drag-and-drop placement – as the user drags an item over the canvas, a highlight or placeholder may indicate where it will be dropped. Upon dropping, the element is added to the card layout. The user repeats this to add all required elements (e.g. title, description, image, button, etc.). Each element on the card may have its own placement (stacked vertically by default, or in specific sections of the card if the layout allows). The user can also reorder elements by dragging them up or down within the card canvas. If an element is not needed, the user can remove it (e.g. by dragging it out or clicking a delete/remove icon). Throughout this process, the Live Preview panel updates immediately to reflect changes – the card is rendered with the newly added elements, showing placeholder data or sample content for each field so the user can visualize the design in real time.
4. **Configure Card Styling:** At any time during the build, the user can apply visual styles from the available theme/effect options. The Card Builder MVP offers a selection of themes and effects to choose from:
   - **Theme:** The user can pick from at least 3 themes for the card’s overall look (e.g. Dark, Light, Neon). The theme will define base colors, background, and text styles for the card.
   - **Shadow Effects:** The user can choose from 3 shadow options (for example: no shadow, a soft shadow, or a strong drop shadow) to alter the card’s elevation appearance.
   - **Lighting/Glow Effects:** The user can choose from 3 lighting effects, such as subtle glow highlights or neon border glows (particularly visible in the Neon theme), to make the card stand out.
   - **Animations:** The user can select one of 3 animation options for the card (e.g. a fade-in on load, a slight hover-grow effect, or a slide-in transition). Animations add interactivity or attention to the card when it appears or is hovered.

   These style options are typically provided as simple dropdowns or toggles in the UI. The user’s selections are immediately reflected in the preview. For example, switching from Light to Dark theme will update the preview card’s colors instantly. Choosing an animation might trigger a demo of that animation in the preview. This allows the designer to experiment with different looks and pick the combination that fits their needs.
5. **View and Edit Code (Toggle):** The Card Builder allows the user to switch between the visual design mode and the “code behind it” on the fly. There is a toggle or tabs for “Design View” and “Code View.” In Code View, the underlying representation of the card is shown – for MVP this could be a JSON schema of the card’s structure, or a React component code snippet. For example, the JSON might list each element and its properties (type, label, validation rules, etc.), and any style settings chosen. The user can directly edit this code if they are comfortable (e.g. adjust a label text, or fine-tune a configuration) and then switch back to Design View to see the effect. Changes made in code are parsed and applied to the visual model of the card. Conversely, any changes made through the drag-and-drop UI are reflected when the user views the code. This two-way synchronization ensures advanced users have full control, while others can rely on visual tools. The Card Builder will validate the code input (e.g. check that the JSON is valid) when switching from Code View to Design View – if there is an error (such as malformed JSON), the user is notified to correct it before the visual preview updates. (For MVP, the code editing might be basic, but in future it could include syntax highlighting or suggestions.)
6. **Validation Assembly:** As the user adds each element to the card, the system automatically incorporates that element’s validation rules into the card’s configuration. Each data element carries its own validation logic (for example, an email field knows it must be a valid email format, a number field might have min/max values, etc.). These rules are bound to the element definition rather than defined at the card level. The Card Builder aggregates these validations into the overall card schema. For instance, if the user added a “Phone Number” input field, the card’s JSON schema will now include the phone number validation (such as regex or length checks) coming from that element’s defaults. The live preview might not actively enforce validation (since it’s mostly for layout/design), but the exported card definition will contain all necessary validation constraints. This means when the card is actually used in the app (e.g. presented in a form to end-users), it will validate inputs according to the rules of each included field automatically. The user designing the card does not need to manually code any validation – it is built behind the scenes by the Card Builder.
7. **Export Card Design:** Once satisfied with the card’s composition and style, the user can export or save the card definition. The MVP will support exporting in a structured format. The likely choice is JSON schema (a machine-readable configuration) because it is easy to persist, edit, and later transform into a UI component. For example, the user clicks an “Export” button, and the builder generates a JSON file (or text) representing the card. This JSON includes all the elements with their settings (order, labels, types, etc.), the chosen theme and style options, and the validation rules for each field. In the current implementation, clicking export triggers a download of a card.json file containing the design. Alternatively, the builder might provide the React component code if that option is selected (in a future enhancement, perhaps the user could choose between “Export JSON” and “Export React Component”). For the MVP, one robust export format is sufficient, with JSON being the primary candidate (as it can be loaded and parsed by the app). The exported definition can then be integrated into the main application – for example, the JSON could be uploaded to the server or inserted into the site configuration so that end-users will see this new card in the appropriate section of the site.
8. **Saving/Loading Designs (Persistence):** In this MVP, there is no full database or cloud persistence of card designs. However, the user can save their work manually. After exporting the JSON, they effectively have a backup of the design. If they want to load a previously saved card, the user can switch to Code View, paste the JSON configuration into the editor, and the builder will reconstruct the card in the Design View. Even without a dedicated “Open” dialog, this copy-paste method allows persistence in a basic way (e.g. the builder might also provide a text area or a file import for JSON). This meets the immediate need without requiring a complex backend. In future versions, a more user-friendly persistence layer (saving designs to a database and listing them in a gallery) can be added, but it’s outside the MVP scope.

### Postconditions

By the end of this use case, the user has a JSON (or code) representation of the new card design, complete with all fields and validations. The design is ready to be used in the Mining Syndicate platform – for instance, the admin might attach this card to an "Action Cards" slide or another UI section so that members of the site will interact with it. The user (admin) can now provide this exported config to the system (or to a developer) to deploy it. The card’s appearance and behavior in production will match what was previewed in the Card Builder.

### Alternative Flows

- **Direct Code Editing:** A technically advanced user might paste a template JSON at the start (or choose a sample card layout) instead of dragging elements one by one. The builder will parse the JSON and load the card in Design View for further tweaking. This allows quick start from existing patterns.
- **Error Handling:** If the user enters an invalid configuration in Code View (e.g., forgets a comma in JSON), the builder will display an error message and not apply the changes until it’s corrected, ensuring the preview doesn’t break.
- **Cancel/Reset:** The user may decide to clear the canvas or start over. A reset button could remove all elements from the card so they can begin fresh.
- **Role Permission:** Only authorized users (e.g., site administrators or designers) have access to the Card Builder. If an unauthorized user tries to access it, the system will prevent access (e.g., not show the option or display a permission error).

## Functional Requirements

The Card Builder must satisfy the following requirements for the MVP:

1. **Data Element Library:** The system shall provide a library of predefined data elements that can be used on a card. Each data element has a unique identifier, a name/label, a data type (text, number, image, etc.), and associated metadata like category and default validation rules. The library may include both simple fields (e.g. text, number) and complex or computed fields. (Example: A “Sum” element that computes a total of other numbers could be a future element type.) The Card Builder UI shall display the available elements in a categorized list, making it easy to find different types of fields.
2. **Element Display Modes:** The system shall enforce each data element’s allowed display form factors. For a given element, the builder must know whether it can be used as a read-only display field, an editable field, or an input field (or some combination). The UI should only present valid display options to the user when adding an element. (For instance, a calculated field might only be displayable (not directly editable by an end-user), whereas a text field might allow both display and input modes.) This ensures that the user cannot configure an element in an unsupported way.
3. **Drag-and-Drop Card Construction:** The Card Builder shall provide a drag-and-drop interface for composing the card. Users can drag elements from the library palette onto the card canvas. When an element is dropped onto the canvas, it is added to the card’s content model. The user shall be able to rearrange the order of elements via dragging (reordering the list or repositioning in designated areas of the card). The interface should visually indicate the drop zones and current order (for example, showing a placeholder line where the field will land). Each added element on the canvas should be presented with a simple representation (e.g., a box showing the element’s label or type) in the preview.
4. **Real-Time Preview:** The system shall display a live preview of the card as it is being built. This preview updates in real time with each change: adding an element, removing an element, reordering, or changing styles. The preview should reflect how the card will look to end-users in the application, using sample or default data for the fields (e.g., “Sample Text” for a text field) if actual data is not available at design time. This immediate feedback is crucial for a WYSIWYG (What-You-See-Is-What-You-Get) experience, allowing the designer to adjust the layout and styling on the fly.
5. **Element Configuration and Properties:** For each element added to the card, the builder shall allow the user to configure element-specific properties. These may include:
   - **Custom Label/Text:** Ability to edit the display label of the field (e.g., renaming “Text” to “Customer Name” on that card if needed).
   - **Placeholder/Default Value:** For input fields, setting placeholder text or default content.
   - **Required/Optional:** Marking whether an input is required (if applicable to that element).
   - **Custom Validation Rules:** (Optional for MVP) If the user needs to override or add validation (e.g., set a specific max length), they could do so via an element settings dialog. By default, the element’s default validation is used, but the builder could let users tweak certain parameters of it.
   - **Styling per Element:** (Future consideration) Possibly allow per-element style adjustments (like making one text field bold or a different color) if in scope. For MVP, most styling is via global themes, not per element, except perhaps resizing an image or choosing an icon for a button, etc., if those are part of data elements.

   Elements in the canvas should be selectable, and a configuration panel or popup allows editing these properties. Changes in properties update the preview immediately.
6. **Theme Selection:** The Card Builder shall offer at least three preset themes (e.g. Dark, Light, Neon) that define the overall aesthetic of the card. Changing the theme in the builder will globally update colors, backgrounds, and fonts in the preview. The theme choice should be recorded in the card’s configuration so that the card will use the same theme when rendered in the live app. The Neon theme will include distinctive colors (e.g. bright pink and blue highlights) to match the provided style guidelines, whereas Dark and Light provide standard options for different background contexts.
7. **Shadow and Lighting Effects:** The system shall provide a selection of shadow effects (minimum 3 options) that can be toggled for the card. These could range from no shadow, to a light shadow, to a heavy shadow or glow. Likewise, lighting effects (at least 3 options) shall be available – these might include effects like a subtle inner glow, an outline highlight, or a neon border light. The user can apply these to enhance the card’s appearance. Technically, these might be implemented as CSS classes or style presets (and the chosen option will be stored as part of the card’s style config). Only one shadow option and one lighting effect can be active at a time (the user picks which one looks best, or “none” if they want a flat look).
8. **Animation Options:** The Card Builder shall include at least three animation choices for the card component. Examples might be:
   - **No Animation:** (Static card, appears with no special effect).
   - **Fade In:** (Card fades into view on load).
   - **Slide Up on Load:** (Card slides up from bottom a bit when it first renders).

   The exact animations can be defined by the design team, but there will be three distinct options to choose from. The builder should allow the user to select one (or none) and preview it. The selected animation is recorded in the card’s configuration (e.g., as a class name or an animation type identifier) so that the live app knows to apply that animation to the card when it renders.
9. **Code View & Editing:** The system shall provide a Code View that shows the underlying representation of the card. For MVP, this will likely be a JSON structure describing the card. The Code View should be accessible via a toggle or tab, and it must always reflect the current state of the card design (e.g., if two text fields and one number field have been added in the UI, the JSON should list those three fields in order with their properties). The user shall be able to edit the code directly. After editing, the system will attempt to parse and apply the updated code back to the design:
   - If the code is valid (no syntax errors and follows the expected schema), the Design View is updated to match the changes.
   - If the code is invalid, the system shall display an error message and not apply the broken changes (the user can fix the code or cancel the edit).

   This allows round-trip editing. The builder should validate important constraints in code form as well – for example, if the user manually adds an element in JSON that isn’t in the data library, or sets an invalid property, the system should ideally warn or ignore those. (Some basic validation is expected, full schema enforcement can be a future improvement.)
10. **Export Format:** The Card Builder shall support exporting the card design for use outside the builder. For MVP, a JSON export is required – the user can click a button to download a .json file or copy the JSON text representing the card. This JSON includes all structural and style information (elements, their order and settings, theme, effects, animations, etc.). The export function should produce a file in a format that the Mining Syndicate app can consume. The current prototype triggers a file download named (for example) card.json containing the card configuration. In addition, the system might later support exporting as a React component or TypeScript module. While not strictly needed in MVP, the design should not preclude adding a “Export as React Component” option in the future, which would generate boilerplate React code for the card (including all chosen elements and possibly using a library of component templates for each data element). The choice between JSON or React export will depend on which offers more flexibility for integration – but at minimum JSON export is implemented.
11. **Import/Load Design:** Corresponding to export, the builder should allow importing a card configuration (for MVP, via a manual step). This means the user can paste a previously exported JSON into the Code View and the builder will reconstruct the card. This requirement ensures that designs are portable: a user can save their work and later continue editing it. A more user-friendly file upload or a gallery of saved cards can be considered later. For now, even a text paste to replace the JSON in Code View is acceptable as the “load” mechanism.
12. **Validation Rules Integration:** The system shall automatically include validation rules from each data element into the card’s definition. The card itself doesn’t define validation, but serves as a container for elements that each have their own validation. For example, if an element from the library has a default validation (like regex for emails, numeric range, required flag, etc.), those rules should appear in the exported JSON schema for that element. The outcome is that any form or process using this card can enforce all field validations without additional manual coding. The builder does not need to validate user input in the preview, but it should ensure the final configuration correctly represents each field’s validation (and if the user changed a validation setting in the builder, that updated rule is what gets exported). This might involve merging multiple field schemas into one card schema behind the scenes.
13. **Integration with Main App:** The card designs produced must be compatible with the Mining Syndicate platform’s data structures. For instance, if the main app expects an Action Card to have certain fields (title, description, etc.), the Card Builder’s output should match or be transformable to that. As part of MVP, the card JSON could be stored in an existing configuration (like the cardConfig of a slide). The requirement is that minimal manual tweaking is needed to use the exported card in the app. (Developers might write a parser to take the JSON and generate the needed database entries or component definitions.) In short, the builder’s output should cleanly integrate with the site’s workflow for adding new cards.
14. **Access Control:** Only authorized users (such as admins or content managers) shall have access to the Card Builder interface. This can be a simple check – for example, the admin dashboard shows the “Card Builder” option only to users with the appropriate role. This ensures regular members or unprivileged users cannot modify card designs. Since the Card Builder might run as a separate development tool in MVP, access control may be inherently limited (it might not even be deployed to production for end-users), but it’s noted for completeness when integrating into a live admin UI.
15. **Usability and Feedback:** The interface should be intuitive and provide feedback for user actions. Requirements to support this include:
   - **Labels and Instructions:** The builder should label sections clearly (“Data Elements”, “Card Preview”, “Properties”, “Code Editor”, etc.) so users know what to do. It might also include a short description or tooltip for each theme/effect option (e.g., hovering “Neon” could show “A dark theme with pink/blue highlights”).
   - **Drag-and-Drop Cues:** When dragging an element, the system should highlight valid drop zones (perhaps the outline of the card turns blue or a line appears where it will be inserted). This visual cue is required to make the drag-and-drop feel natural.
   - **Error Messages:** If something goes wrong (like invalid code input, or an unsupported operation), a clear error or warning message should inform the user what happened. For example, “Invalid JSON format – please check syntax” on the code editor if parse fails.
   - **Responsive Design:** (If this tool is used in a browser) It should be usable at least on a desktop screen. Mobile support is not a priority for the builder (admins are likely to use desktop), but the UI should handle reasonably sized browser windows.
   - **Performance:** Adding elements or switching themes should update the preview with minimal delay (preferably nearly instant, under a second). The drag-and-drop interactions should feel smooth (no jarring lag), accomplished by using efficient front-end techniques (the prototype leverages a DnD library for smooth interactions).

## Non-Functional Requirements and Considerations

1. **Technology Stack:** The Card Builder will be built as a React application (as suggested by the existing integration) and likely reuse components from the design system (for fields, buttons, etc.). It should maintain consistency with the rest of the platform’s tech stack. For example, if the platform uses certain UI components or CSS frameworks, the Card Builder should use them for the preview to ensure what you see in the builder is what you get in the actual app.
2. **Maintainability:** The system should be designed in a modular way – new data elements (fields) can be added to the library without massive rewrites. Likewise, adding a new theme or style option in the future should be straightforward (e.g., the code could read theme definitions from a config rather than having them hard-coded in many places).
3. **Scalability:** Although MVP handles a single card at a time, eventually multiple card templates might be designed. The underlying data format and storage approach should allow scaling to many saved card designs. Also, if cards become more complex (nested structures, dynamic content), the builder’s architecture should be able to accommodate those enhancements.
4. **Testing & Validation:** The Card Builder features should be tested thoroughly. This includes UI tests for drag-and-drop behavior, ensuring the preview updates correctly, and unit tests for the code export (i.e., verify that a given set of elements in the builder produces the expected JSON output). Also, validate that the JSON output, when fed back into the system, results in a correctly functioning card.
5. **Security:** If the Card Builder is available in a live environment, ensure that any APIs it uses (e.g., to fetch the data element library or to save a design) are secured and only accessible by authorized roles. Additionally, if custom code input is allowed (in Code View), guard against any injection of malicious scripts – though JSON is not executable, a React component export might need sanitization if user-edited.
6. **User Experience:** The overall UX should make it easy and even fun for a user to build a card. This includes using drag-and-drop, which is intuitive, providing real-time visual confirmation, and not requiring the user to write any code unless they want to. By combining visual design with optional code editing, the builder caters to both non-technical content managers and developer-oriented users.

## Conclusion

The Card Builder will significantly streamline how custom cards (such as call-to-action cards, informational cards, etc.) are created and styled within the Mining Syndicate platform. By meeting the above requirements, the MVP will deliver a functional tool where users can assemble a card from predefined data elements, customize its look with themes and effects, and export it for integration – all without manual coding. This empowers the team to quickly create and iterate on UI components in a visual manner, ensuring consistency (through the data library and validation) and efficiency in deployment. Future enhancements can build upon this foundation, adding richer libraries of elements, more styling options, and persistent storage of designs, but the MVP focuses on the core use case: design a card visually, view its code, and output a ready-to-use configuration. The end result is a flexible card designing experience aligned with the platform’s needs and ready to be used by the team or potentially by clients in a controlled way.
